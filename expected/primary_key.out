--PRIMARY KEY
SELECT * FROM pglogical_regress_variables()
\gset
\c :provider_dsn
-- testing update of primary key
-- create  table with primary key and 3 other tables referencing it
SELECT pglogical.replicate_ddl_command($$
CREATE TABLE public.pk_users (
    id integer PRIMARY KEY,
    another_id integer unique not null,
    a_id integer,
    name text,
    address text
);

--pass
$$);
 replicate_ddl_command 
-----------------------
 t
(1 row)

SELECT * FROM pglogical.replication_set_add_table('default', 'pk_users');
 replication_set_add_table 
---------------------------
 t
(1 row)

INSERT INTO pk_users VALUES(1,11,1,'User1', 'Address1');
INSERT INTO pk_users VALUES(2,12,1,'User2', 'Address2');
INSERT INTO pk_users VALUES(3,13,2,'User3', 'Address3');
INSERT INTO pk_users VALUES(4,14,2,'User4', 'Address4');
SELECT * FROM pk_users;
 id | another_id | a_id | name  | address  
----+------------+------+-------+----------
  1 |         11 |    1 | User1 | Address1
  2 |         12 |    1 | User2 | Address2
  3 |         13 |    2 | User3 | Address3
  4 |         14 |    2 | User4 | Address4
(4 rows)

SELECT attname, attnotnull, attisdropped from pg_attribute where attrelid = 'pk_users'::regclass and attnum > 0 order by attnum;
  attname   | attnotnull | attisdropped 
------------+------------+--------------
 id         | t          | f
 another_id | t          | f
 a_id       | f          | f
 name       | f          | f
 address    | f          | f
(5 rows)

SELECT pglogical.wait_slot_confirm_lsn(NULL, NULL);
 wait_slot_confirm_lsn 
-----------------------
 
(1 row)

\c :subscriber_dsn
SELECT * FROM pk_users;
 id | another_id | a_id | name  | address  
----+------------+------+-------+----------
  1 |         11 |    1 | User1 | Address1
  2 |         12 |    1 | User2 | Address2
  3 |         13 |    2 | User3 | Address3
  4 |         14 |    2 | User4 | Address4
(4 rows)

\c :provider_dsn
UPDATE pk_users SET address='UpdatedAddress1' WHERE id=1;
SELECT pglogical.wait_slot_confirm_lsn(NULL, NULL);
 wait_slot_confirm_lsn 
-----------------------
 
(1 row)

\c :subscriber_dsn
SELECT * FROM pk_users;
 id | another_id | a_id | name  |     address     
----+------------+------+-------+-----------------
  2 |         12 |    1 | User2 | Address2
  3 |         13 |    2 | User3 | Address3
  4 |         14 |    2 | User4 | Address4
  1 |         11 |    1 | User1 | UpdatedAddress1
(4 rows)

\c :provider_dsn
\set VERBOSITY terse
SELECT pglogical.replicate_ddl_command($$
CREATE UNIQUE INDEX another_id_temp_idx ON public.pk_users (another_id);
ALTER TABLE public.pk_users DROP CONSTRAINT pk_users_pkey,
    ADD CONSTRAINT pk_users_pkey PRIMARY KEY USING INDEX another_id_temp_idx;

ALTER TABLE public.pk_users DROP CONSTRAINT pk_users_another_id_key;
$$);
NOTICE:  ALTER TABLE / ADD CONSTRAINT USING INDEX will rename index "another_id_temp_idx" to "pk_users_pkey"
 replicate_ddl_command 
-----------------------
 t
(1 row)

SELECT attname, attnotnull, attisdropped from pg_attribute where attrelid = 'pk_users'::regclass and attnum > 0 order by attnum;
  attname   | attnotnull | attisdropped 
------------+------------+--------------
 id         | t          | f
 another_id | t          | f
 a_id       | f          | f
 name       | f          | f
 address    | f          | f
(5 rows)

UPDATE pk_users SET address='UpdatedAddress2' WHERE id=2;
SELECT pglogical.wait_slot_confirm_lsn(NULL, NULL);
 wait_slot_confirm_lsn 
-----------------------
 
(1 row)

\c :subscriber_dsn
SELECT attname, attnotnull, attisdropped from pg_attribute where attrelid = 'pk_users'::regclass and attnum > 0 order by attnum;
  attname   | attnotnull | attisdropped 
------------+------------+--------------
 id         | t          | f
 another_id | t          | f
 a_id       | f          | f
 name       | f          | f
 address    | f          | f
(5 rows)

SELECT * FROM pk_users;
 id | another_id | a_id | name  |     address     
----+------------+------+-------+-----------------
  3 |         13 |    2 | User3 | Address3
  4 |         14 |    2 | User4 | Address4
  1 |         11 |    1 | User1 | UpdatedAddress1
  2 |         12 |    1 | User2 | UpdatedAddress2
(4 rows)

\c :provider_dsn
UPDATE pk_users SET address='UpdatedAddress3' WHERE another_id=12;
SELECT pglogical.wait_slot_confirm_lsn(NULL, NULL);
 wait_slot_confirm_lsn 
-----------------------
 
(1 row)

\c :subscriber_dsn
SELECT * FROM pk_users;
 id | another_id | a_id | name  |     address     
----+------------+------+-------+-----------------
  3 |         13 |    2 | User3 | Address3
  4 |         14 |    2 | User4 | Address4
  1 |         11 |    1 | User1 | UpdatedAddress1
  2 |         12 |    1 | User2 | UpdatedAddress3
(4 rows)

\c :provider_dsn
UPDATE pk_users SET address='UpdatedAddress4' WHERE a_id=2;
SELECT pglogical.wait_slot_confirm_lsn(NULL, NULL);
 wait_slot_confirm_lsn 
-----------------------
 
(1 row)

\c :subscriber_dsn
INSERT INTO pk_users VALUES(4,15,2,'User5', 'Address5');
-- subscriber now has duplicated value in id field while provider does not
SELECT * FROM pk_users;
 id | another_id | a_id | name  |     address     
----+------------+------+-------+-----------------
  1 |         11 |    1 | User1 | UpdatedAddress1
  2 |         12 |    1 | User2 | UpdatedAddress3
  3 |         13 |    2 | User3 | UpdatedAddress4
  4 |         14 |    2 | User4 | UpdatedAddress4
  4 |         15 |    2 | User5 | Address5
(5 rows)

\c :provider_dsn
\set VERBOSITY terse
SELECT quote_literal(pg_current_xlog_location()) as curr_lsn
\gset
SELECT pglogical.replicate_ddl_command($$
CREATE UNIQUE INDEX id_temp_idx ON public.pk_users (id);
ALTER TABLE public.pk_users DROP CONSTRAINT pk_users_pkey,
    ADD CONSTRAINT pk_users_pkey PRIMARY KEY USING INDEX id_temp_idx;
$$);
NOTICE:  ALTER TABLE / ADD CONSTRAINT USING INDEX will rename index "id_temp_idx" to "pk_users_pkey"
 replicate_ddl_command 
-----------------------
 t
(1 row)

SELECT attname, attnotnull, attisdropped from pg_attribute where attrelid = 'pk_users'::regclass and attnum > 0 order by attnum;
  attname   | attnotnull | attisdropped 
------------+------------+--------------
 id         | t          | f
 another_id | t          | f
 a_id       | f          | f
 name       | f          | f
 address    | f          | f
(5 rows)

SELECT pglogical.wait_slot_confirm_lsn(NULL, :curr_lsn);
 wait_slot_confirm_lsn 
-----------------------
 
(1 row)

\c :subscriber_dsn
SELECT attname, attnotnull, attisdropped from pg_attribute where attrelid = 'pk_users'::regclass and attnum > 0 order by attnum;
  attname   | attnotnull | attisdropped 
------------+------------+--------------
 id         | t          | f
 another_id | t          | f
 a_id       | f          | f
 name       | f          | f
 address    | f          | f
(5 rows)

SELECT pglogical.alter_subscription_disable('test_subscription', true);
 alter_subscription_disable 
----------------------------
 t
(1 row)

\c :provider_dsn
-- Wait for subscription to disconnect. It will have been bouncing already
-- due to apply worker restarts, but if it was retrying it'll stay down
-- this time.
DO $$
BEGIN
	FOR i IN 1..100 LOOP
		IF (SELECT count(1) FROM pg_replication_slots WHERE active = false) THEN
			RETURN;
		END IF;
		PERFORM pg_sleep(0.1);
	END LOOP;
END;
$$;
SELECT data::json->'action' as action, CASE WHEN data::json->>'action' IN ('I', 'D', 'U') THEN json_extract_path(data::json, 'relation') END as data FROM pg_logical_slot_get_changes((SELECT slot_name FROM pg_replication_slots), NULL, 1, 'min_proto_version', '1', 'max_proto_version', '1', 'startup_params_format', '1', 'proto_format', 'json', 'pglogical.replication_set_names', 'default,ddl_sql');
 action |         data          
--------+-----------------------
 "S"    | 
 "B"    | 
 "I"    | ["pglogical","queue"]
 "C"    | 
(4 rows)

SELECT data::json->'action' as action, CASE WHEN data::json->>'action' IN ('I', 'D', 'U') THEN data END as data FROM pg_logical_slot_get_changes((SELECT slot_name FROM pg_replication_slots), NULL, 1, 'min_proto_version', '1', 'max_proto_version', '1', 'startup_params_format', '1', 'proto_format', 'json', 'pglogical.replication_set_names', 'default,ddl_sql');
 action | data 
--------+------
(0 rows)

\c :subscriber_dsn
SELECT pglogical.alter_subscription_enable('test_subscription', true);
 alter_subscription_enable 
---------------------------
 t
(1 row)

DELETE FROM pk_users WHERE id = 4;-- remove the offending entries.
\c :provider_dsn
DO $$
BEGIN
	FOR i IN 1..100 LOOP
		IF (SELECT count(1) FROM pg_replication_slots WHERE active = true) THEN
			RETURN;
		END IF;
		PERFORM pg_sleep(0.1);
	END LOOP;
END;
$$;
UPDATE pk_users SET address='UpdatedAddress2' WHERE id=2;
SELECT pglogical.wait_slot_confirm_lsn(NULL, NULL);
 wait_slot_confirm_lsn 
-----------------------
 
(1 row)

\c :subscriber_dsn
SELECT * FROM pk_users;
 id | another_id | a_id | name  |     address     
----+------------+------+-------+-----------------
  1 |         11 |    1 | User1 | UpdatedAddress1
  3 |         13 |    2 | User3 | UpdatedAddress4
  2 |         12 |    1 | User2 | UpdatedAddress2
(3 rows)

\c :provider_dsn
--
-- Test to show that we don't defend against alterations to tables
-- that will break replication once added to a repset, or prevent
-- dml that would break on apply.
--
-- See 2ndQuadrant/pglogical_internal#146
--
-- Show that the current PK is not marked 'indisreplident' because we use
-- REPLICA IDENTITY DEFAULT
SELECT indisreplident FROM pg_index WHERE indexrelid = 'pk_users_pkey'::regclass;
 indisreplident 
----------------
 f
(1 row)

SELECT relreplident FROM pg_class WHERE oid = 'pk_users'::regclass;
 relreplident 
--------------
 d
(1 row)

SELECT pglogical.replicate_ddl_command($$
ALTER TABLE public.pk_users DROP CONSTRAINT pk_users_pkey;
$$);
 replicate_ddl_command 
-----------------------
 t
(1 row)

INSERT INTO pk_users VALUES(90,0,0,'User90', 'Address90');
-- pglogical will stop us adding the table to a repset if we try to,
-- but didn't stop us altering it, and won't stop us updating it...
BEGIN;
SELECT * FROM pglogical.replication_set_remove_table('default', 'pk_users');
 replication_set_remove_table 
------------------------------
 t
(1 row)

SELECT * FROM pglogical.replication_set_add_table('default', 'pk_users');
ERROR:  table pk_users cannot be added to replication set default
ROLLBACK;
-- Per 2ndQuadrant/pglogical_internal#146 this shouldn't be allowed, but
-- currently is. Logical decoding will fail to capture this change and we
-- won't progress with decoding.
--
-- This will get recorded by logical decoding with no 'oldkey' values,
-- causing pglogical to fail to apply it with an error like
--
--    CONFLICT: remote UPDATE on relation public.pk_users (tuple not found). Resolution: skip.
--
UPDATE pk_users SET id = 91 WHERE id = 90;
-- Catchup will replay the insert and succeed, but the update
-- will be lost.
BEGIN;
SET statement_timeout = '2s';
SELECT pglogical.wait_slot_confirm_lsn(NULL, NULL);
ERROR:  canceling statement due to statement timeout
ROLLBACK;
-- To carry on we'll need to make the index on the downstream
-- (which is odd, because logical decoding didn't capture the
--  oldkey of the tuple, so how can we apply it?)
\c :subscriber_dsn
ALTER TABLE public.pk_users
    ADD CONSTRAINT pk_users_pkey PRIMARY KEY (id) NOT DEFERRABLE;
\c :provider_dsn
ALTER TABLE public.pk_users
    ADD CONSTRAINT pk_users_pkey PRIMARY KEY (id) NOT DEFERRABLE;
SELECT pglogical.wait_slot_confirm_lsn(NULL, NULL);
 wait_slot_confirm_lsn 
-----------------------
 
(1 row)

-- Demonstrate that deferrable indexes aren't yet supported for updates on downstream
-- and will fail with an informative error.
SELECT pglogical.replicate_ddl_command($$
ALTER TABLE public.pk_users
    DROP CONSTRAINT pk_users_pkey,
    ADD CONSTRAINT pk_users_pkey PRIMARY KEY (id) DEFERRABLE INITIALLY DEFERRED;
$$);
 replicate_ddl_command 
-----------------------
 t
(1 row)

-- Not allowed, deferrable
ALTER TABLE public.pk_users REPLICA IDENTITY USING INDEX pk_users_pkey;
ERROR:  cannot use non-immediate index "pk_users_pkey" as replica identity
-- New index isn't REPLICA IDENTITY either
SELECT indisreplident FROM pg_index WHERE indexrelid = 'pk_users_pkey'::regclass;
 indisreplident 
----------------
 f
(1 row)

-- pglogical won't let us add the table to a repset, though
-- it doesn't stop us altering it; see 2ndQuadrant/pglogical_internal#146
BEGIN;
SELECT * FROM pglogical.replication_set_remove_table('default', 'pk_users');
 replication_set_remove_table 
------------------------------
 t
(1 row)

SELECT * FROM pglogical.replication_set_add_table('default', 'pk_users');
ERROR:  table pk_users cannot be added to replication set default
ROLLBACK;
-- We can still INSERT (which is fine)
INSERT INTO pk_users VALUES(100,0,0,'User100', 'Address100');
-- FIXME pglogical shouldn't allow this, no valid replica identity exists
-- see 2ndQuadrant/pglogical_internal#146
UPDATE pk_users SET id = 101 WHERE id = 100;
-- Must time out, apply will fail on downstream due to no replident index
BEGIN;
SET statement_timeout = '2s';
SELECT pglogical.wait_slot_confirm_lsn(NULL, NULL);
ERROR:  canceling statement due to statement timeout
ROLLBACK;
\c :subscriber_dsn
-- entry 100 must be absent since we can't apply it without
-- a suitable pk
SELECT id FROM pk_users WHERE id IN (90, 91, 100, 101) ORDER BY id;
 id  
-----
  90
 100
(2 rows)

-- we can recover by re-creating the pk as non-deferrable
ALTER TABLE public.pk_users DROP CONSTRAINT pk_users_pkey,
    ADD CONSTRAINT pk_users_pkey PRIMARY KEY (id) NOT DEFERRABLE;
\c :provider_dsn
-- then replay
SELECT pglogical.wait_slot_confirm_lsn(NULL, NULL);
 wait_slot_confirm_lsn 
-----------------------
 
(1 row)

\c :subscriber_dsn
SELECT id FROM pk_users WHERE id IN (90, 91, 100, 101) ORDER BY id;
 id  
-----
  90
 100
(2 rows)

\c :provider_dsn
-- Subscriber and provider have diverged due to inability to replicate
-- the UPDATEs
SELECT id FROM pk_users WHERE id IN (90, 91, 100, 101) ORDER BY id;
 id  
-----
  91
 101
(2 rows)

\set VERBOSITY terse
SELECT pglogical.replicate_ddl_command($$
	DROP TABLE public.pk_users CASCADE;
$$);
NOTICE:  drop cascades to table public.pk_users membership in replication set default
 replicate_ddl_command 
-----------------------
 t
(1 row)

